<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>An Introduction to Kubernetes FlexVolumes | lbr.</title>

<meta name="description" content="Engineering, DevOps & Cloud Computing
">
<meta name="keywords" content="kubernetes, volumes, storage, FlexVolume">
<link rel="canonical" href="/blog/2017/03/12/kubernetes-flexvolumes.html">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-34865189-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-34865189-1');
</script>


<!--Feature assets-->
<!--Bootstrap JS-->
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ho+j7jyWK8fNQe+A12Hb8AhRq26LrZ/JpcUGGOn+Y7RsweNrtN/tE3MoK7ZeZDyx" crossorigin="anonymous"></script>

<!--Font Awesome-->
<link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css" integrity="sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p" crossorigin="anonymous"/>

<!--Highlight.js-->
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.3.2/build/styles/default.min.css">
<script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.3.2/build/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<!--Main assets-->
<link rel="icon" type="image/jpeg" href="/favicon.png"/>
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
<link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
<div class="wrapper">
<header class="header">
<div class="navigation">

<a href="/" class="logo">lbr.</a>

<ul class="menu">
<li class="menu__entry"><a href="/">about</a></li>
<li class="menu__entry"><a href="/projects">projects</a></li>
<li class="menu__entry"><a href="/blog">blog</a></li>
</ul>
</div>
<ul class="social-links">

<a href="mailto:/contact@leebriggs.co.uk" class="social-links__entry" target="_blank">
<i class="fas fa-envelope-square"></i>
</a>


<a href="https://github.com//jaxxstorm" class="social-links__entry" target="_blank">
<i class="fab fa-github"></i>
</a>


<a href="https://linkedin.com/in//briggsl" class="social-links__entry" target="_blank">
<i class="fab fa-linkedin-in"></i>
</a>

</ul>
</header>

<br>
<br>
<h1 class="post-title">
    <div class="post-title__text">An Introduction to Kubernetes FlexVolumes</div>
</h1>
<p class="post-title__subtitle">Published Mar 12, 2017  by <a href="https://leebriggs.co.uk/">Lee Briggs<a><br />


    <span class="badge badge-info">#kubernetes</span>

    <span class="badge badge-info">#volumes</span>

    <span class="badge badge-info">#storage</span>

    <span class="badge badge-info">#FlexVolume</span>

<hr>
<br>
<p>Kubernetes has a reputation for being great for stateless application deployment. If you don’t require any kind of local storage inside your containers, the barrier to entry for you to deploy on Kubernetes is probably very, very low. However, it’s a fact of life that some applications require <em>some</em> kind of local storage.</p>

<p>Kubernetes supports this using <a href="https://kubernetes.io/docs/user-guide/volumes/">Volumes</a> and out of the box there is support for more than enough volume types for the average kubernetes user. For example, if your kubernetes cluster is deployed to AWS, you’re probably going to make use make use of the <a href="https://kubernetes.io/docs/user-guide/volumes/#awselasticblockstore">awsElasticBlockStore</a> volume type, and think very little of it.</p>

<p>There are situations however, where you might be deploying your cluster to a different platform, like physical datacenters or perhaps another “cloud” provider like <a href="https://www.digitalocean.com/">DigitalOcean</a>. In these situations, you might think you’re a little bit screwed, and up until recently you kind of were. The only way to get a new storage provider supported in Kubernetes was to write one, and then run the gauntlet of getting a merge request accepted into the main kubernetes repo.</p>

<p>However, a new volume type has opened up the door to custom volume providers, and they are exceptionally simple to write and use. <a href="https://github.com/kubernetes/kubernetes/blob/master/examples/volumes/FlexVolume/README.md">FlexVolumes</a> are a relatively new addition to the kubernetes volume list, and they allow you to run an arbitrary script or volume provisioner on the kubernetes host to create a volume.</p>

<p>Before we dive too deep into FlexVolumes, it’s worth refreshing exactly how volumes work on Kubernetes and how they are mapped into the container.</p>

<h1 id="volumes-crash-course">Volumes Crash Course</h1>

<p>If you’ve been using Volumes in Kubernetes in a cloud provider, you might not be fully aware of exactly how they work. If you are aware, I suggest you skip ahead. For those that aren’t, let’s have a quick overview of how EBS volumes work in Kubernetes.</p>

<h2 id="create-an-ebs-volume">Create an EBS Volume.</h2>

<p>The first thing you have to do is create an EBS volume. If you’re using the <a href="https://aws.amazon.com/cli/">AWS CLI</a> this is easy as:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">aws ec2 create-volume <span class="nt">--availability-zone</span> eu-west-1c <span class="nt">--size</span> 10 <span class="nt">--volume-type</span> gp2</code></pre></figure>

<p>Which will return something like..</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">{</span>
    <span class="s2">"AvailabilityZone"</span>: <span class="s2">"eu-west-1c"</span>,
    <span class="s2">"Encrypted"</span>: <span class="nb">false</span>,
    <span class="s2">"VolumeType"</span>: <span class="s2">"gp2"</span>,
    <span class="s2">"VolumeId"</span>: <span class="s2">"vol-xxxxxxxxxxxxxxxxx"</span>,
    <span class="s2">"State"</span>: <span class="s2">"creating"</span>,
    <span class="s2">"Iops"</span>: 100,
    <span class="s2">"SnapshotId"</span>: <span class="s2">""</span>,
    <span class="s2">"CreateTime"</span>: <span class="s2">"2017-03-12T14:49:36.377Z"</span>,
    <span class="s2">"Size"</span>: 10
<span class="o">}</span></code></pre></figure>

<p>Your EBS volume is now ready to go.</p>

<p>Once you have the volume, you’ll probably want to attach it to a Kubernetes pod! In order to do this, you’ll need to take the volume ID and use it in your kubernetes manifest. The <a href="https://kubernetes.io/docs/user-guide/volumes/#awselasticblockstore">awsElasticBlockStore</a> has an example, like so:</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">test-ebs</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">image</span><span class="pi">:</span> <span class="s">gcr.io/google_containers/test-webserver</span>
    <span class="na">name</span><span class="pi">:</span> <span class="s">test-container</span>
    <span class="na">volumeMounts</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/test-ebs</span>
      <span class="na">name</span><span class="pi">:</span> <span class="s">test-volume</span>
  <span class="na">volumes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">test-volume</span>
    <span class="na">awsElasticBlockStore</span><span class="pi">:</span>
      <span class="na">volumeID</span><span class="pi">:</span> <span class="s">vol-xxxxxxxxxxxxxxxxx</span>
      <span class="na">fsType</span><span class="pi">:</span> <span class="s">ext4</span></code></pre></figure>

<p>Now, if you look in the pod, you’ll see a mount at <code class="language-plaintext highlighter-rouge">/test-ebs</code>, but how has it got there? The answer is actually surprisingly simple.</p>

<p>If you examine the ebs volume that was created, you’ll see it’s been attached to an instance!</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">aws ec2 describe-volumes <span class="nt">--volume-ids</span> vol-xxxxxxxxxxxxxxxxx
<span class="o">{</span>
    <span class="s2">"Volumes"</span>: <span class="o">[</span>
        <span class="o">{</span>
            <span class="s2">"AvailabilityZone"</span>: <span class="s2">"eu-west-1c"</span>,
            <span class="s2">"Attachments"</span>: <span class="o">[</span>
                <span class="o">{</span>
                    <span class="s2">"AttachTime"</span>: <span class="s2">"2017-03-12T14:53:55.000Z"</span>,
                    <span class="s2">"InstanceId"</span>: <span class="s2">"i-xxxxxxxxxxxxxxxxx"</span>, &lt;&lt; <span class="nt">---</span> attached to an instance
                    <span class="s2">"VolumeId"</span>: <span class="s2">"vol-xxxxxxxxxxxxxxxxx"</span>,
                    <span class="s2">"State"</span>: <span class="s2">"attached"</span>,
                    <span class="s2">"DeleteOnTermination"</span>: <span class="nb">false</span>,
                    <span class="s2">"Device"</span>: <span class="s2">"/dev/xvdba"</span>
                <span class="o">}</span>
            <span class="o">]</span>,
            <span class="s2">"Encrypted"</span>: <span class="nb">false</span>,
            <span class="s2">"VolumeType"</span>: <span class="s2">"gp2"</span>,
            <span class="s2">"VolumeId"</span>: vol-xxxxxxxxxxxxxxxxx<span class="s2">",
            "</span>State<span class="s2">": "</span><span class="k">in</span><span class="nt">-use</span><span class="s2">",
            "</span>Iops<span class="s2">": 100,
            "</span>SnapshotId<span class="s2">": "",
            "</span>CreateTime<span class="s2">": "</span>2017-03-12T14:49:36.377Z<span class="s2">",
            "</span>Size<span class="s2">": 10
        }
    ]
}</span></code></pre></figure>

<p>So let’s log into this host, and find the device:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">findmnt /dev/xvdba
TARGET                                                                                               SOURCE     FSTYPE OPTIONS
/var/lib/kubelet/plugins/kubernetes.io/aws-ebs/mounts/vol-xxxxxxxxxxxxxxxxx                          /dev/xvdba ext4   rw,relatime,data<span class="o">=</span>ordered
/var/lib/kubelet/pods/b6c57370-0733-11e7-8421-06533dc554b3/volumes/kubernetes.io~aws-ebs/test-volume /dev/xvdba ext4   rw,relatime,data<span class="o">=</span>ordered</code></pre></figure>

<p>As you can see here, it’s mounted on the host under the <code class="language-plaintext highlighter-rouge">/var/lib/kubelet</code> directory. This gives us a clue as to how this happened, but to confirm, you can examine the kubelet logs and you’ll see things like this:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">Mar 12 14:54:11 ip-172-20-57-70 kubelet[1199]: I0312 14:54:11.716670    1199 operation_executor.go:832] MountVolume.WaitForAttach succeeded <span class="k">for </span>volume <span class="s2">"kubernetes.io/aws-ebs/vol-xxxxxxxxxxxxxxxxx"</span> <span class="o">(</span>spec.Name: <span class="s2">"test-volume"</span><span class="o">)</span> pod <span class="s2">"b6c57370-0733-11e7-8421-06533dc554b3"</span> <span class="o">(</span>UID: <span class="s2">"b6c57370-0733-11e7-8421-06533dc554b3"</span><span class="o">)</span><span class="nb">.</span>
...
Mar 12 14:54:15 ip-172-20-57-70 kubelet[1199]: I0312 14:54:15.738019    1199 mount_linux.go:369] Disk successfully formatted <span class="o">(</span>mkfs<span class="o">)</span>: ext4 - /dev/xvdba /var/lib/kubelet/plugins/kubernetes.io/aws-ebs/mounts/vol-xxxxxxxxxxxxxxxxx</code></pre></figure>

<p>The main point here is that when we provide a pod with a volume mount, it’s the <strong>kubelet</strong> that takes care of the process. All it does it mount the external volume (in this case the EBS volume) onto a directory on the host (under the <code class="language-plaintext highlighter-rouge">/var/lib/kubelet</code> dir) and then from there, it can map that volume into the container. There isn’t any fancy magic on the container side, it’s essentially just a normal <a href="https://docs.docker.com/engine/tutorials/dockervolumes/">docker volume</a> to the container.</p>

<h1 id="flexvolumes-examined">FlexVolumes examined</h1>

<p>Okay, so now we know how volumes work in Kubernetes, we can start to examine how FlexVolumes work.</p>

<p>FlexVolumes are essentially very simple scripts executed by the Kubelet on the host. The script should have 5 functions</p>

<ul>
  <li>init - to initialize the volume driver. This could be just an empty function if needed</li>
  <li>attach - to attach the volume to the host. In many cases, this might be empty, but in some cases, like for EBS, you might have to make an API call to attach it to the host</li>
  <li>mount - mount the volume <em>on</em> the host. This is the important part, and is the part that makes the volume available to to the host to mount it in <code class="language-plaintext highlighter-rouge">/var/lib/kubelet</code></li>
  <li>unmount - hopefully self explanatory - unmount the volume</li>
  <li>detach - again, hopefully self explanatory - detach the volume from the external host.</li>
</ul>

<p>For each of these functions, there’s some parameters passed to the function as scripts arguments (such as <code class="language-plaintext highlighter-rouge">$1</code>, <code class="language-plaintext highlighter-rouge">$2</code>, <code class="language-plaintext highlighter-rouge">$3</code>). 
The last passed argument is interesting, because it’s actually a JSON string with options from the driver (more on this later) These parameters specify options that are important to the function, as as we examine a real world example they should become more clear.</p>

<h2 id="lvm-example">LVM Example</h2>

<p>The kubernetes repo has a helpful <a href="https://github.com/kubernetes/kubernetes/blob/master/examples/volumes/FlexVolume/lvm">LVM example</a> in the form of a bash script, which makes it nice and readable and easy to understand. Let’s look at some of the functions..</p>

<h3 id="init">Init</h3>

<p>The init function is very simple, as LVM doesn’t require and initialization:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$op</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"init"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
	</span>log <span class="s2">"{</span><span class="se">\"</span><span class="s2">status</span><span class="se">\"</span><span class="s2">: </span><span class="se">\"</span><span class="s2">Success</span><span class="se">\"</span><span class="s2">}"</span>
	<span class="nb">exit </span>0
<span class="k">fi</span></code></pre></figure>

<p>Notice how we’re returning JSON here, which isn’t much fun in bash!</p>

<h3 id="attach">Attach</h3>

<p>The attach function for the LVM example simply determines if the device exists. Because we don’t have to do any API calls to a cloud provider, this makes it quite simple:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">attach<span class="o">()</span> <span class="o">{</span>
	<span class="nv">JSON_PARAMS</span><span class="o">=</span><span class="nv">$1</span>
	<span class="nv">SIZE</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="nv">$1</span> | jq <span class="nt">-r</span> <span class="s1">'.size'</span><span class="si">)</span>

	<span class="nv">DMDEV</span><span class="o">=</span><span class="si">$(</span>getdevice<span class="si">)</span>
	<span class="k">if</span> <span class="o">[</span> <span class="o">!</span> <span class="nt">-b</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DMDEV</span><span class="k">}</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
		</span>err <span class="s2">"{</span><span class="se">\"</span><span class="s2">status</span><span class="se">\"</span><span class="s2">: </span><span class="se">\"</span><span class="s2">Failure</span><span class="se">\"</span><span class="s2">, </span><span class="se">\"</span><span class="s2">message</span><span class="se">\"</span><span class="s2">: </span><span class="se">\"</span><span class="s2">Volume </span><span class="k">${</span><span class="nv">VOLUMEID</span><span class="k">}</span><span class="s2"> does not exist</span><span class="se">\"</span><span class="s2">}"</span>
		<span class="nb">exit </span>1
	<span class="k">fi
	</span>log <span class="s2">"{</span><span class="se">\"</span><span class="s2">status</span><span class="se">\"</span><span class="s2">: </span><span class="se">\"</span><span class="s2">Success</span><span class="se">\"</span><span class="s2">, </span><span class="se">\"</span><span class="s2">device</span><span class="se">\"</span><span class="s2">:</span><span class="se">\"</span><span class="k">${</span><span class="nv">DMDEV</span><span class="k">}</span><span class="se">\"</span><span class="s2">}"</span>
	<span class="nb">exit </span>0
<span class="o">}</span></code></pre></figure>

<p>As you saw earlier, the LVM device needs to exist before we can mount it (in the EBS example earlier, we had to create the device) and so during the attach phase, we ensure the device is available.</p>

<h3 id="mount">Mount</h3>

<p>The final stage is the mount section.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">domountdevice<span class="o">()</span> <span class="o">{</span>
	<span class="nv">MNTPATH</span><span class="o">=</span><span class="nv">$1</span>
	<span class="nv">DMDEV</span><span class="o">=</span><span class="nv">$2</span>
	<span class="nv">FSTYPE</span><span class="o">=</span><span class="si">$(</span><span class="nb">echo</span> <span class="nv">$3</span>|jq <span class="nt">-r</span> <span class="s1">'.["kubernetes.io/fsType"]'</span><span class="si">)</span>

	<span class="k">if</span> <span class="o">[</span> <span class="o">!</span> <span class="nt">-b</span> <span class="s2">"</span><span class="k">${</span><span class="nv">DMDEV</span><span class="k">}</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
		</span>err <span class="s2">"{</span><span class="se">\"</span><span class="s2">status</span><span class="se">\"</span><span class="s2">: </span><span class="se">\"</span><span class="s2">Failure</span><span class="se">\"</span><span class="s2">, </span><span class="se">\"</span><span class="s2">message</span><span class="se">\"</span><span class="s2">: </span><span class="se">\"</span><span class="k">${</span><span class="nv">DMDEV</span><span class="k">}</span><span class="s2"> does not exist</span><span class="se">\"</span><span class="s2">}"</span>
		<span class="nb">exit </span>1
	<span class="k">fi

	if</span> <span class="o">[</span> <span class="si">$(</span>ismounted<span class="si">)</span> <span class="nt">-eq</span> 1 <span class="o">]</span> <span class="p">;</span> <span class="k">then
		</span>log <span class="s2">"{</span><span class="se">\"</span><span class="s2">status</span><span class="se">\"</span><span class="s2">: </span><span class="se">\"</span><span class="s2">Success</span><span class="se">\"</span><span class="s2">}"</span>
		<span class="nb">exit </span>0
	<span class="k">fi

	</span><span class="nv">VOLFSTYPE</span><span class="o">=</span><span class="sb">`</span>blkid <span class="nt">-o</span> udev <span class="k">${</span><span class="nv">DMDEV</span><span class="k">}</span> 2&gt;/dev/null|grep <span class="s2">"ID_FS_TYPE"</span>|cut <span class="nt">-d</span><span class="s2">"="</span> <span class="nt">-f2</span><span class="sb">`</span>
	<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="k">${</span><span class="nv">VOLFSTYPE</span><span class="k">}</span><span class="s2">"</span> <span class="o">==</span> <span class="s2">""</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
		</span>mkfs <span class="nt">-t</span> <span class="k">${</span><span class="nv">FSTYPE</span><span class="k">}</span> <span class="k">${</span><span class="nv">DMDEV</span><span class="k">}</span> <span class="o">&gt;</span>/dev/null 2&gt;&amp;1
		<span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
			</span>err <span class="s2">"{ </span><span class="se">\"</span><span class="s2">status</span><span class="se">\"</span><span class="s2">: </span><span class="se">\"</span><span class="s2">Failure</span><span class="se">\"</span><span class="s2">, </span><span class="se">\"</span><span class="s2">message</span><span class="se">\"</span><span class="s2">: </span><span class="se">\"</span><span class="s2">Failed to create fs </span><span class="k">${</span><span class="nv">FSTYPE</span><span class="k">}</span><span class="s2"> on device </span><span class="k">${</span><span class="nv">DMDEV</span><span class="k">}</span><span class="se">\"</span><span class="s2">}"</span>
			<span class="nb">exit </span>1
		<span class="k">fi
	fi

	</span><span class="nb">mkdir</span> <span class="nt">-p</span> <span class="k">${</span><span class="nv">MNTPATH</span><span class="k">}</span> &amp;&gt; /dev/null

	mount <span class="k">${</span><span class="nv">DMDEV</span><span class="k">}</span> <span class="k">${</span><span class="nv">MNTPATH</span><span class="k">}</span> &amp;&gt; /dev/null
	<span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> <span class="nt">-ne</span> 0 <span class="o">]</span><span class="p">;</span> <span class="k">then
		</span>err <span class="s2">"{ </span><span class="se">\"</span><span class="s2">status</span><span class="se">\"</span><span class="s2">: </span><span class="se">\"</span><span class="s2">Failure</span><span class="se">\"</span><span class="s2">, </span><span class="se">\"</span><span class="s2">message</span><span class="se">\"</span><span class="s2">: </span><span class="se">\"</span><span class="s2">Failed to mount device </span><span class="k">${</span><span class="nv">DMDEV</span><span class="k">}</span><span class="s2"> at </span><span class="k">${</span><span class="nv">MNTPATH</span><span class="k">}</span><span class="se">\"</span><span class="s2">}"</span>
		<span class="nb">exit </span>1
	<span class="k">fi
	</span>log <span class="s2">"{</span><span class="se">\"</span><span class="s2">status</span><span class="se">\"</span><span class="s2">: </span><span class="se">\"</span><span class="s2">Success</span><span class="se">\"</span><span class="s2">}"</span>
	<span class="nb">exit </span>0
<span class="o">}</span></code></pre></figure>

<p>This is a little bit more involved, but still relatively simple. Essentially, what happens here is:</p>
<ul>
  <li>The passed device is formatted to a filesystem provided in the parameters</li>
  <li>A directory is created to mount the volume to</li>
  <li>it’s then mounted to a mountpath by the kubelet</li>
</ul>

<h3 id="parameters">Parameters</h3>

<p>You may be wondering, where do these parameters I keep talking about come from? The answer is from the pod manifest sent to the kubelet. Here’s an example that uses the above LVM FlexVolume:</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">kind</span><span class="pi">:</span> <span class="s">Pod</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
  <span class="na">namespace</span><span class="pi">:</span> <span class="s">default</span>
<span class="na">spec</span><span class="pi">:</span>
  <span class="na">containers</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">nginx</span>
    <span class="na">volumeMounts</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">test</span>
      <span class="na">mountPath</span><span class="pi">:</span> <span class="s">/data</span>
    <span class="na">ports</span><span class="pi">:</span>
    <span class="pi">-</span> <span class="na">containerPort</span><span class="pi">:</span> <span class="m">80</span>
  <span class="na">volumes</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">name</span><span class="pi">:</span> <span class="s">test</span>
    <span class="na">flexVolume</span><span class="pi">:</span>
      <span class="na">driver</span><span class="pi">:</span> <span class="s2">"</span><span class="s">leebriggs.co.uk/lvm"</span>
      <span class="na">fsType</span><span class="pi">:</span> <span class="s2">"</span><span class="s">ext4"</span>
      <span class="na">options</span><span class="pi">:</span>
        <span class="na">volumeID</span><span class="pi">:</span> <span class="s2">"</span><span class="s">vol1"</span>
        <span class="na">size</span><span class="pi">:</span> <span class="s2">"</span><span class="s">1000m"</span>
        <span class="na">volumegroup</span><span class="pi">:</span> <span class="s2">"</span><span class="s">kube_vg"</span></code></pre></figure>

<p>The key section here is the “options” section. This volume ID, size and volume group is all passed to the kubelet as <code class="language-plaintext highlighter-rouge">$3</code> as a JSON string, which is why there’s a bunch of <a href="https://stedolan.github.io/jq/">jq</a> munging happening in the above scripts.</p>

<h1 id="using-flexvolumes">Using FlexVolumes</h1>
<p>Now you understand how FlexVolumes work, you need to make the kubelet aware of them. Currently, the only way to do this is to install them on the host under a specific directory.</p>

<p>FlexVolumes need a “namespace” (for want of a better word) and a name. So for example, my personally built lvm FlexVolume might be <code class="language-plaintext highlighter-rouge">leebriggs.co.uk/lvm</code>. When we install our script, it needs to be installed like so on the host that runs the kubelet:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">mkdir</span> <span class="nt">-p</span> /usr/libexec/kubernetes/kubelet-plugins/volume/exec/leebriggs.co.uk~lvm
<span class="nb">mv </span>lvm /usr/libexec/kubernetes/kubelet-plugins/volume/exec/leebriggs.co.uk~lvm/lvm</code></pre></figure>

<p>Once you’ve done this, restart the kubelet, and you should be able to use your FlexVolume as you need.</p>

<h2 id="manifest">Manifest</h2>

<p>The manifest above give you an example of how to use FlexVolumes. It’s worth noting that not all FlexVolumes will be in the same format though. Make sure the driver name matches the directory under the <code class="language-plaintext highlighter-rouge">exec</code> folder (in our case, <code class="language-plaintext highlighter-rouge">leebriggs.co.uk~lvm</code> and that you pass your required options around.</p>

<h1 id="wrapping-up">Wrapping up</h1>

<p>This was a relative crash course in FlexVolumes for Kubernetes. There are a couple problems with it:</p>

<ul>
  <li>The example is written in bash, which isn’t great at manipulating JSON</li>
  <li>It uses LVM, which isn’t exactly multi host compatible</li>
</ul>

<p>The first point is easily solved, by writing a driver in a language with JSON parsing built in. There are a few FlexVolume drivers popping up in <a href="https://golang.org/">Go</a> - <a href="https://github.com/jaxxstorm/ploop-flexvol">I wrote one</a> for <a href="https://openvz.org/Ploop">ploop</a> in Go using a <a href="https://github.com/jaxxstorm/FlexVolume">library</a> which was written to ease the process, but there are  others:</p>

<ul>
  <li>Github user <a href="https://github.com/tonyzou/">TonyZuo</a> has written a couple of interesting ones. One  for <a href="https://www.digitalocean.com/">DigitalOcean</a> and one for <a href="https://www.packet.net/">Packet</a>. Check them out <a href="https://github.com/tonyzou/FlexVolumes">here</a></li>
  <li>There’s a <a href="https://github.com/rancher/rancher-flexvol">Rancher Flexvolume</a> for those using Rancher</li>
  <li>Finally, one very interesting one is this <a href="https://github.com/fcantournet/kubernetes-FlexVolume-vault-plugin">Vault Flexvolume</a> which can map <a href="https://vaultproject.io">Vault</a> to directories inside containers.</li>
</ul>

<p>All of this deals with mapping single, static volumes into containers, but there is more. Currently, you have to manually provision the volumes you use before spinning up a pod, and as you start to create more and more volumes, you may want to deal with <a href="https://kubernetes.io/docs/user-guide/persistent-volumes/">Persistent Volumes</a> to have a process that automatically creates the volumes for you. My next post will detail how you can <em>use</em> these FlexVolumes in a custom provisioner which resembles the persistent volumes in AWS and GCE!</p>

<br>

<div id="disqus_thread"></div>
<script>


var disqus_config = function () {
this.page.url = 'https://leebriggs.co.uk/assets/style.css';
this.page.identifier = '/blog/2017/03/12/kubernetes-flexvolumes.html'; 
};

(function() {
var d = document, s = d.createElement('script');
s.src = 'https://.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            

<br>
<div class="about">
<div class="about__devider">*****</div>
<div class="about__text">
<br>
&#169 2021, Lee Briggs | <a href="https://github.com/ritijjain/pudhina-fresh">Pudhina Fresh</a> theme for Jekyll.
</div>
</div>

</div>
</body>
</html>
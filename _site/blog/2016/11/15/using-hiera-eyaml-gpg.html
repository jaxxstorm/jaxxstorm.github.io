<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">

<title>Using hiera-eyaml-gpg | lbr.</title>

<meta name="description" content="Engineering, DevOps & Cloud Computing
">
<meta name="keywords" content="puppet">
<link rel="canonical" href="/blog/2016/11/15/using-hiera-eyaml-gpg.html">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-34865189-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-34865189-1');
</script>


<!--Feature assets-->
<!--Bootstrap JS-->
<script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ho+j7jyWK8fNQe+A12Hb8AhRq26LrZ/JpcUGGOn+Y7RsweNrtN/tE3MoK7ZeZDyx" crossorigin="anonymous"></script>

<!--Font Awesome-->
<link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css" integrity="sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p" crossorigin="anonymous"/>

<!--Highlight.js-->
<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.3.2/build/styles/default.min.css">
<script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.3.2/build/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<!--Main assets-->
<link rel="icon" type="image/jpeg" href="/favicon.png"/>
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
<link rel="stylesheet" href="/assets/css/main.css">
</head>
<body>
<div class="wrapper">
<header class="header">
<div class="navigation">

<a href="/" class="logo">lbr.</a>

<ul class="menu">
<li class="menu__entry"><a href="/">about</a></li>
<li class="menu__entry"><a href="/projects">projects</a></li>
<li class="menu__entry"><a href="/blog">blog</a></li>
</ul>
</div>
<ul class="social-links">

<a href="mailto:/contact@leebriggs.co.uk" class="social-links__entry" target="_blank">
<i class="fas fa-envelope-square"></i>
</a>


<a href="https://github.com//jaxxstorm" class="social-links__entry" target="_blank">
<i class="fab fa-github"></i>
</a>


<a href="https://linkedin.com/in//briggsl" class="social-links__entry" target="_blank">
<i class="fab fa-linkedin-in"></i>
</a>

</ul>
</header>

<br>
<br>
<h1 class="post-title">
    <div class="post-title__text">Using hiera-eyaml-gpg</div>
</h1>
<p class="post-title__subtitle">Published Nov 15, 2016  by <a href="https://leebriggs.co.uk/">Lee Briggs<a><br />


    <span class="badge badge-info">#puppet</span>

<hr>
<br>
<p>Every company that uses Puppet eventually gets to the stage in their development where they want to store “secrets” within Puppet. Usually (hopefully!) your Puppet manifests and data will be stored in version control in plaintext and therefore adding these secrets to your manifests has some clear security concerns which need to be addressed.</p>

<p>You <em>could</em> just restrict the data to a few select people, and have it in a separate control repo, but at the end of the day, your secrets will still be in plaintext and you’re at the mercy of your version control ACLs.</p>

<p>Fortunately, a bunch of very smart people came across this problem a while ago and gave us the solutions we need to be able to solve the problem.</p>

<p><a href="https://github.com/TomPoulton/hiera-eyaml">hiera-eyaml</a> has been around a while now and gives you the capability to encrypt secrets stored in hiera. It provides an <code class="language-plaintext highlighter-rouge">eyaml</code> command line tool to make use of this, and will encrypt values for you using a pluggable backend. By default, it uses asymmetric encryption (PKCS#7) and will make any value indecipherable to anyone who has the key. You can see the example in the linked github repo, but for verbosity sake, it looks like this:</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="nn">---</span>
<span class="na">plain-property</span><span class="pi">:</span> <span class="s">You can see me</span>

<span class="na">encrypted-property</span><span class="pi">:</span> <span class="pi">&gt;</span>
    <span class="s">ENC[PKCS7,Y22exl+OvjDe+drmik2XEeD3VQtl1uZJXFFF2NnrMXDWx0csyqLB/2NOWefv</span>
    <span class="s">NBTZfOlPvMlAesyr4bUY4I5XeVbVk38XKxeriH69EFAD4CahIZlC8lkE/uDh</span>
    <span class="s">jJGQfh052eonkungHIcuGKY/5sEbbZl/qufjAtp/ufor15VBJtsXt17tXP4y</span>
    <span class="s">l5ZP119Fwq8xiREGOL0lVvFYJz2hZc1ppPCNG5lwuLnTekXN/OazNYpf4CMd</span>
    <span class="s">/HjZFXwcXRtTlzewJLc+/gox2IfByQRhsI/AgogRfYQKocZgFb/DOZoXR7wm</span>
    <span class="s">IZGeunzwhqfmEtGiqpvJJQ5wVRdzJVpTnANBA5qxeA==]</span></code></pre></figure>

<p>In order to see the encrypted-property, you need to have access to the preshared key you used to encrypt the value, which means you have to copy the pre-shared key to your master. This is fine if you’re a single user managing a small number of Puppetmasters, but as your team scales this actually introduces a security consideration.</p>

<p>How do you pass the preshared key around? The more people that touch that key, the less secure it becomes. Distributing it to 20 odd people means that if a single user’s laptop is compromised, <em>all</em> your secrets will be under threat. Fortunately, there’s a better way of managing this which is facilitated by the plugin system hiera-eyaml supports, and the solution is <a href="https://github.com/sihil/hiera-eyaml-gpg">hiera-eyaml-gpg</a></p>

<h2 id="using-gpg-keys">Using GPG Keys</h2>

<p>The problem with hiera-eyaml-gpg is that the documentation only shows you how to set up hiera-eyaml-gpg, but you then have to go off and do a bunch of reading about how GPG keys work. If you already know how GPG keys work, skip ahead, this isn’t for you! If you don’t, let’s cover quickly how GPG keys work, and how this helps us solve the single key problem above.</p>

<h3 id="quick-overview">Quick Overview</h3>

<p>In a nutshell, GPG is a hybrid public and private key encryption system. In a bullet point format:</p>

<ul>
  <li>Each user or entity has a public and private key pair.</li>
  <li>Public keys are used for encryption, private keys are used for decryption. Messages can be signed by encrypting a hash of the message using the sender’s private key, allowing the receiver to verify the integrity of the data by using the sender’s public key to decrypt the hash.</li>
  <li>Private keys need to be kept secure by the owner.</li>
  <li>Public keys need to be transferred reliably such that they cannot be altered, and substitute keys inserted.</li>
  <li>You can encrypt data for multiple recipients, by using all of their public keys together. Any of them will be able to decrypt the data using their own private key.</li>
  <li>A user can add a set of other user’s public keys to their GPG public keyring. Users create a “web of trust” by validating and signing user’s keys in their keyrings.</li>
</ul>

<p>Thinking of this from a Puppet perspective:</p>

<ul>
  <li>Each puppetmaster (or sets of puppetmasters) will have their own public and private GPG key pair. The private keys will be kept local on the puppetmasters and should not be transferred anywhere else.</li>
  <li>Each user that will be editing the secure data within puppet will also have a public and private key pair. They will keep their private key secure and private to themselves.</li>
  <li>Each user will need to have all of the public keys of all puppetmasters, along with all other eyaml users, added to their own public keyring.</li>
  <li>When a new user or new puppetmaster is added or a key is changed, all users will need to update their keyrings with the new public keys. Additionally, all encrypted data in hiera will need to be re-encrypted so that the new puppetmasters and users are able to decrypt the encrypted data.</li>
  <li>If a puppetmaster gets compromised, or a user leaves the company, only the key for that puppetmaster (or set of puppetmasters) needs to be removed from the keyrings and encrypted data. None of the other puppetmaster or user keys need to be updated.</li>
</ul>

<p>As you can see, this drastically improves security of your important data stored in hiera. With that in mind, let’s get started..</p>

<h3 id="generate-a-gpg-key">Generate a GPG Key</h3>

<p>There are plenty of docs out there to explain how to generate a GPG key for each OS. In a short form, you should do this:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">gpg <span class="nt">--gen-key</span></code></pre></figure>

<p>You’ll get a handy menu prompt that will help you generate a key. <strong>SET A PASSPHRASE</strong>. Having a blank passphrase will compromise the whole web of trust for your encrypted data.</p>

<h3 id="generate-a-gpg-key-for-your-puppetmaster">Generate a GPG Key for your Puppetmaster</h3>

<p>Because GPG operates on the concept of each user using different keys, you’ll now need to generate a key for your Puppetmaster.</p>

<p>If you’re lucky, you can just use the above command and have done with it. In order to be more specific, here’s the way I know works to generate keys:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="c"># Use a reasonable directory for gpghome</span>
<span class="nb">mkdir</span> <span class="nt">-m</span> 0700 /etc/puppetlabs/.gpghome
<span class="nb">chown </span>puppet:puppet /etc/puppet/.gpghome</code></pre></figure>

<p>Now, the GPG we generate for the puppetmasters need some special attributes, so we’ll need a custom batch config file at <code class="language-plaintext highlighter-rouge">/etc/puppetlabs/.gpghome/keygen.inp</code>. Make sure you replace <code class="language-plaintext highlighter-rouge">_keyname_</code> with something useful, like maybe <code class="language-plaintext highlighter-rouge">puppetmaster</code></p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">%echo Generating a default key
Key-Type: default
Subkey-Type: default
Name-Real: _keyname_
Expire-Date: 0
%no-ask-passphrase
%no-protection
%commit
%echo <span class="k">done</span></code></pre></figure>

<p>Now, generate the key:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">sudo</span> <span class="nt">-u</span> puppet gpg <span class="nt">--homedir</span> /etc/puppet/.gpghome <span class="nt">--gen-key</span> <span class="nt">--batch</span> /etc/puppet/.gpghome/keygen.inp</code></pre></figure>

<p>Now that’s done, you should see a GPG key in your puppetmaster’s keyring:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">sudo</span> <span class="nt">-u</span> puppet gpg <span class="nt">--homedir</span> /etc/puppet/.gpghome <span class="nt">--list-keys</span>
gpg: checking the trustdb
gpg: 3 marginal<span class="o">(</span>s<span class="o">)</span> needed, 1 <span class="nb">complete</span><span class="o">(</span>s<span class="o">)</span> needed, PGP trust model
gpg: depth: 0  valid:   1  signed:   0  trust: 0-, 0q, 0n, 0m, 0f, 1u
/etc/puppet/.gpghome/pubring.gpg
<span class="nt">--------------------------------</span>
pub   2048R/XXXXXXXX 2016-11-14
uid                  puppetmaster
sub   2048R/XXXXXXX 2016-11-14</code></pre></figure>

<h3 id="a-web-of-trust">A web of trust</h3>

<p>GPG keys operate under the model that everyone has their own public and private key, and everyone in your team trusts each other (hopefully you trust your colleagues!). In the previous step, you generated a key, now, you need to make sure all your colleagues sign your key to verify its authenticity and confirm it’s valid. In order to do this, you need to distribute your <em>public</em> key to everyone and they need to sign it.</p>

<p>The way you distribute the public keys is up to you, but there are tools like <a href="https://keybase.io">Keybase</a> or private keyservers available which you may choose to use. Obviously, it’s not recommended to send your puppetmasters GPG key to keybase. The most important consideration here is that the public keys can’t be modified in transit somehow. This means sending the GPG keys via email over the internet is probably not a fantastic idea, however sending to your colleagues via internal email probably wouldn’t be so terrible.</p>

<p>At a very minimum, you’ll need to sign the keys from your puppetmaster that you generated earlier. In order to do that, export the key in ASCII format:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">sudo</span> <span class="nt">-u</span> puppet gpg <span class="nt">--homedir</span> /etc/puppet/.gpghome <span class="nt">--export</span> <span class="nt">-a</span> <span class="nt">-o</span> /etc/puppet/.gpghome/puppetmaster.pub</code></pre></figure>

<p>Copy the <code class="language-plaintext highlighter-rouge">puppetmaster.pub</code> file locally so it’s ready to import.</p>

<p>In order to sign it, copy the file locally to your machine from $distribution_method and then run this:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">gpg <span class="nt">--import</span> /path/to/file.pub</code></pre></figure>

<p>From here, you need to verify the signature, and if you’re happy, sign the key:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">gpg <span class="nt">--sign-key</span> &lt;keyname&gt;</code></pre></figure>

<p>You’ll need to enter your own GPG keys’ passphrase in order to sign the key.</p>

<p>Everyone who’s going to be using encrypted yaml will need to perform this step for each of the keypairs you generate. This means when a new user joins the company, you’ll have to import and sign the keys that users generates. There are puppet modules which ease this process, and you can simply add a public key to a puppetmaster’s keyring by using <a href="https://github.com/n1tr0g/golja-gnupg">golja-gnupg</a></p>

<h2 id="puppet-hiera-and-gpg-keys">Puppet, Hiera and GPG Keys</h2>

<p>If you’ve now created a web of trust, you need to make Puppet aware of the GPG keys. Firstly, you’ll need to generate a GPG key for your masters. We group our masters into different tiers, dev/stg and prod, and we ensure these keys are distinctly separate. Then, make sure the key is signed by the relevant people, otherwise it’s pretty much useless :)</p>

<p>Once your keys and gpg config are set up, you’ll need to get <code class="language-plaintext highlighter-rouge">hiera-eyaml-gpg</code> working.</p>

<h3 id="install-hiera-eyaml-gpg">Install hiera-eyaml-gpg</h3>

<p>The installation requirements are clearly spelled out <a href="https://github.com/sihil/hiera-eyaml-gpg#requirements">here</a> but for clarity’s sake, I’ll cover the process here. The process is basically the same for both users who’ll be using eyaml to encrypt values, and puppetmasters who will be encrypting values. From an OS perspective, you’ll need to make sure you have the <code class="language-plaintext highlighter-rouge">ruby</code>, <code class="language-plaintext highlighter-rouge">ruby-devel</code>, <code class="language-plaintext highlighter-rouge">rubygems</code> and <code class="language-plaintext highlighter-rouge">gpgme</code> packages installed. On CentOS, that looks like this:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">sudo </span>yum <span class="nb">install </span>ruby gpgme rubygems ruby-devel</code></pre></figure>

<p>Then, install the required rubygems in the relevant ruby path. If you’re using the latest version of puppetserver, you’ll need to install this using <code class="language-plaintext highlighter-rouge">puppetserver gem install</code></p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">sudo </span>gem <span class="nb">install </span>gpgme
<span class="nb">sudo </span>gem <span class="nb">install </span>hiera-eyaml
<span class="nb">sudo </span>gem <span class="nb">install </span>hiera-eyaml-gpg</code></pre></figure>

<h3 id="the-recipients-file">The Recipients File</h3>

<p>One of the main ways that <code class="language-plaintext highlighter-rouge">hiera-eyaml-gpg</code> differs from standard <code class="language-plaintext highlighter-rouge">hiera-eyaml</code> is the <code class="language-plaintext highlighter-rouge">gpg.recipients</code> file. This file essentially lists the GPG keys that are available to decrypt secrets with a directory in hiera. This is an incredibly powerful tool, especially if you wish to allow users to encrypt/decrypt some secrets in your environment, but not others.</p>

<p>When the <code class="language-plaintext highlighter-rouge">eyaml</code> command is invoked, it will search in the current working directory for this file, and if one is not found it will go up through the directory tree until one is found. As an example, your hieradats directory might look like this:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">├── development
│   ├── app1
│   │   └── hiera-eyaml-gpg.recipients
│   └── app2
│       └── hiera-eyaml-gpg.recipients
└── production
    ├── dc1
    │   ├── base.eyaml
    │   └── hiera-eyaml-gpg.recipients
    ├── hiera-eyaml-gpg.recipients
    └── role.eyaml</code></pre></figure>

<p>With this kind of layout, it’s possible to allow users access to certain app credentials, datacenters or even environments, without compromising all the credentials in hiera.</p>

<p>The format of the hiera-eyaml-gpg.recipients file is simple, it simply lists the GPG keys that are allowed to encrypt/decrypt values:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">puppetmaster-prod
lbriggs
a_nother_user</code></pre></figure>

<p>The value of this can be found in the uid field of the <code class="language-plaintext highlighter-rouge">gpg --list-keys</code> command.</p>

<h3 id="modify-hierayaml">Modify hiera.yaml</h3>

<p>The final step in the process is to make <code class="language-plaintext highlighter-rouge">hiera</code> aware of this GPG plugin. Update to <code class="language-plaintext highlighter-rouge">hiera.yaml</code> to look like this:</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="nn">---</span>
<span class="s">:backends:</span>
  <span class="s">- yaml</span>
  <span class="s">- eyaml</span>
<span class="s">:hierarchy:</span>
  <span class="s">- "nodes/%{clientcert}"</span>
<span class="s">:yaml:</span>
  <span class="s">:datadir: "/etc/puppet/environments/%{environment}/hieradata"</span>
<span class="s">:eyaml:</span>
  <span class="s">:datadir: "/etc/puppet/environments/%{environment}/hieradata"</span>
  <span class="s">:gpg_gnupghome: /etc/puppet/.gpghome</span>
  <span class="s">:extension: 'eyaml'</span></code></pre></figure>

<p>At this point, puppet should use the GPG extension, assuming you installed it correctly previously</p>

<h2 id="adding-an-encrypted-parameter">Adding an Encrypted Parameter</h2>

<p>At this stage, you’ve done the following:</p>

<ul>
  <li>Generated GPG keys for all the human users who will be encrypting/decrypting values</li>
  <li>Generated GPG keys for the puppetmasters which will be decrypting values</li>
  <li>Shared the public keys around all the above to ensure they’re trusted</li>
  <li>Installed the components required for Puppet to use GPG keys</li>
  <li>Set up the <code class="language-plaintext highlighter-rouge">hiera-eyaml-gpg.recipients</code> file so <code class="language-plaintext highlighter-rouge">hiera-eyaml-gpg</code> knows who can read/write values.</li>
</ul>

<p>The final step here is adding an encrypted value to hiera. When you did <code class="language-plaintext highlighter-rouge">gem install hiera-eyaml</code> you also got a handy command line tool to help with this.</p>

<p>In order to use it simply run the following:</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="s">eyaml edit hieradata/&lt;folder&gt;/&lt;file&gt;.eyaml</span></code></pre></figure>

<p>You’ll be asked to enter your GPG key password, and then you’ll get dropped into an editor with something like this in the header:</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="c1">#| This is eyaml edit mode. This text (lines starting with #| at the top of the</span>
<span class="c1">#| file) will be removed when you save and exit.</span>
<span class="c1">#|  - To edit encrypted values, change the content of the DEC(&lt;num&gt;)::PKCS7[]!</span>
<span class="c1">#|    block (or DEC(&lt;num&gt;)::GPG[]!).</span>
<span class="c1">#|    WARNING: DO NOT change the number in the parentheses.</span>
<span class="c1">#|  - To add a new encrypted value copy and paste a new block from the</span>
<span class="c1">#|    appropriate example below. Note that:</span>
<span class="c1">#|     * the text to encrypt goes in the square brackets</span>
<span class="c1">#|     * ensure you include the exclamation mark when you copy and paste</span>
<span class="c1">#|     * you must not include a number when adding a new block</span>
<span class="c1">#|    e.g. DEC::PKCS7[]! -or- DEC::GPG[]!</span></code></pre></figure>

<p>As we noted, you’re using the GPG plugin, so add your value like so:</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="s">class::class::parameter: DEC::GPG[correct_horse_battery_staple]!</span></code></pre></figure>

<p>When you save the file, you can cat it again and you’ll see the value is now encrypted:</p>

<figure class="highlight"><pre><code class="language-yaml" data-lang="yaml"><span class="s">class::class::parameter: ENC[GPG,XXXXXXXXXXXXXXXXXXXXXXXXXXXXX=]</span></code></pre></figure>

<p>From here, you can push it to git and have it downloaded using the method you use to grab your config (I hope you’re using r10k!) and the puppetmaster (assuming you set up the GPG encryption correctly!) will be able to decrypt these secret and service it to hosts.</p>

<p>Happy encrypting!</p>

<br>

<div id="disqus_thread"></div>
<script>


var disqus_config = function () {
this.page.url = 'http://localhost:4000/assets/style.css';
this.page.identifier = '/blog/2016/11/15/using-hiera-eyaml-gpg.html'; 
};

(function() {
var d = document, s = d.createElement('script');
s.src = 'https://.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                            

<br>
<div class="about">
<div class="about__devider">*****</div>
<div class="about__text">
<br>
&#169 2021, Lee Briggs | <a href="https://github.com/ritijjain/pudhina-fresh">Pudhina Fresh</a> theme for Jekyll.
</div>
</div>

</div>
</body>
</html>